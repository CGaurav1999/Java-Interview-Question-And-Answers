==============================================
          JAVA CONCURRENCY - INTERVIEW FAQ
==============================================

ğŸ”¹ 1. What is Future?
----------------------------------
âœ” Future (Java 5) represents a pending async computation.
âŒ Blocking get() â€“ Inefficient, must wait for the result.
âŒ No chaining â€“ Cannot combine multiple Future results.
âŒ No exception handling â€“ Requires manual try-catch.
âŒ No manual completion â€“ We cannot complete it manually.


ğŸ”¹ 2. What is CompletableFuture?
----------------------------------
âœ” CompletableFuture (Java 8) is an enhanced Future that supports:
âœ… Non-blocking execution (callbacks instead of get())
âœ… Chaining multiple async tasks
âœ… Exception handling
âœ… Manual completion

ğŸ“Œ Key Features:
----------------------------------
â¤ (i) Chaining Asynchronous Tasks
```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 10)
    .thenApply(num -> num * 2)
    .thenApply(num -> num + 5);
System.out.println("Final Result: " + future.get()); // 25
```

â¤ (ii) Running Tasks in Parallel (thenCombine)
```java
CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);
CompletableFuture<Integer> result = future1.thenCombine(future2, (num1, num2) -> num1 + num2);
System.out.println("Combined Result: " + result.get()); // 30
```

â¤ (iii) Handling Exceptions
```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
    if (true) throw new RuntimeException("Error!");
    return 10;
}).exceptionally(ex -> {
    System.out.println("Handled: " + ex.getMessage());
    return 0;
});
System.out.println("Result: " + future.get()); // 0 (fallback)
```

â¤ (iv) Running Multiple Tasks (allOf & anyOf)
```java
CompletableFuture<Void> allTasks = CompletableFuture.allOf(
    CompletableFuture.runAsync(() -> System.out.println("Task 1")),
    CompletableFuture.runAsync(() -> System.out.println("Task 2")),
    CompletableFuture.runAsync(() -> System.out.println("Task 3"))
);
allTasks.get(); // Wait for all tasks
System.out.println("All tasks completed.");
```


ğŸ”¹ 3. What is BlockingQueue?
----------------------------------
âœ” A thread-safe queue that blocks when adding/removing elements under certain conditions.
âœ” Used in producer-consumer problems.

ğŸ“Œ Characteristics:
âœ” Thread Safety â€“ Multiple threads can add/remove elements safely.
âœ” Blocking Behavior â€“
   ğŸ”¸ If full, producer waits for space.
   ğŸ”¸ If empty, consumer waits for an element.
âœ” No Null Values allowed.
âœ” Implementations â€“ ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue.


ğŸ”¹ 4. Difference: BlockingQueue vs. ConcurrentLinkedQueue
----------------------------------
ğŸ“Œ **BlockingQueue**
âœ” Supports waiting if empty or full.
âœ” Uses locks/semaphores.
âœ” Suitable for producer-consumer models.
âœ” Can be bounded (e.g., ArrayBlockingQueue) or unbounded.

ğŸ“Œ **ConcurrentLinkedQueue**
âœ” Non-blocking (poll() returns null if empty).
âœ” Uses CAS (Compare-And-Swap) for lock-free operations.
âœ” High-throughput, but no blocking support.


ğŸ”¹ 5. Feature Comparison Table
----------------------------------
| Feature               | BlockingQueue         | ConcurrentLinkedQueue |
|-----------------------|----------------------|-----------------------|
| **Thread Safety**    | âœ… Yes (locks)       | âœ… Yes (lock-free)   |
| **Blocking Ops**     | âœ… Yes (waits)       | âŒ No (never blocks) |
| **Locking**          | Uses locks/semaphores | Lock-free (CAS)       |
| **Performance**      | Slower (locks)        | Faster (lock-free)    |
| **Use Case**         | Producer-Consumer     | High-throughput       |
| **Capacity**         | Bounded/unbounded     | Unbounded             |
| **Null Values**      | âŒ Not allowed        | âŒ Not allowed        |


ğŸ”¹ 6. Fail-Fast vs. Fail-Safe Iterators
----------------------------------
âœ” **Fail-Fast:** Throws ConcurrentModificationException if modified during iteration.
   (e.g., ArrayList, HashMap)
âœ” **Fail-Safe:** Works on a copy, allowing modification during iteration.
   (e.g., ConcurrentHashMap, CopyOnWriteArrayList)


ğŸ”¹ 7. CopyOnWriteArrayList
----------------------------------
âœ” CopyOnWriteArrayList creates a new copy on modification.
âœ” Thread-safe but slower for writes.
âœ” Ideal for read-heavy scenarios.


ğŸ”¹ 8. ConcurrentSkipListMap in Java
----------------------------------
âœ” A thread-safe, sorted map alternative to ConcurrentHashMap.
âœ” Uses Skip Lists (O(log n) complexity).

ğŸ“Œ Key Features:
âœ” âœ… Thread-safe (lock-free, CAS-based)
âœ” âœ… Sorted order of keys
âœ” âŒ No null keys allowed
âœ” âœ… Allows null values
âœ” âœ… Best for read-heavy workloads


ğŸ”¹ 9. Why is Vector thread-safe but not recommended?
----------------------------------
âœ” Vector uses synchronized methods, making it slower than ArrayList.
âœ” Alternatives: Collections.synchronizedList() or CopyOnWriteArrayList.


ğŸ”¹ 10. How does ReadWriteLock improve performance?
----------------------------------
âœ” Allows multiple readers but only one writer at a time.
âœ” Ideal for high-read, low-write scenarios.


ğŸ”¹ 11. ThreadLocal Variable in Java
----------------------------------
âœ” Provides thread-local storage (each thread gets its own copy).
âœ” Avoids synchronization issues.
âœ” Use cases: Database connections, user sessions, locale preferences.
âœ” Automatically removed when a thread terminates.


ğŸ”¹ 12. What is the Fork/Join framework?
----------------------------------
âœ” Used for parallel processing.
âœ” Divides tasks into smaller sub-tasks for concurrent execution.


ğŸ”¹ 13. How to prevent race conditions in Java Collections?
----------------------------------
âœ” Use synchronized collections (e.g., Collections.synchronizedList()).
âœ” Use concurrent collections (e.g., ConcurrentHashMap, CopyOnWriteArrayList).
âœ” Use atomic variables (AtomicInteger, AtomicReference).


ğŸ”¹ 14. Atomic Variables in Java
----------------------------------
âœ” Part of java.util.concurrent.atomic.
âœ” Provides lock-free, thread-safe operations using CAS.
âœ” Faster than synchronized blocks.
âœ” Used for counters, flags, references.


ğŸš€ **End of Java Concurrency Cheat Sheet** ğŸš€
==============================================
